# Zsh data-types

在 Zsh 的底层设计中，数据结构的设计非常精巧，旨在平衡 **Shell 的字符串处理本质**与**通用编程语言的高效性**。

以下是 Zsh 最核心的四种数据结构及其技术特性：

---

### 1. 标量 (Scalars / Strings)

这是最基础的类型。在 Zsh 中，所有变量默认几乎都是标量（字符串）。

- **技术特性**：Zsh 的标量不仅仅是字符数组，它支持极其复杂的**参数展开标志 (Parameter Expansion Flags)**。
- **经典操作**：

```zsh
var="hello world"
echo ${var:u}      # HELLO WORLD (转大写)
echo ${var//o/0}   # hell0 w0rld (全局替换)

```

---

### 2. 数组 (Arrays)

Zsh 的数组是它区别于 Bash/Sh 最强大的地方。

- **技术特性**：
- **下标从 1 开始**（与大多数脚本语言一致，与 C 语言不同）。
- **真正的内存数组**：操作效率远高于字符串切割。
- **自动修剪**：支持空值剔除和唯一化。

- **关联变量 (Tying)**：如前所述，`$path` 数组与 `$PATH` 标量是通过底层 C 代码绑定的。
- **高级切片**：

```zsh
arr=(a b c d e)
echo $arr[2,4]    # 输出 b c d
echo $arr[(i)c]   # 返回元素 'c' 的索引 (3)

```

---

### 3. 关联数组 (Associative Arrays / Hashes)

类似于 Python 的字典或 JavaScript 的对象。

- **技术特性**：
- **必须显式声明**：使用 `typeset -A`。
- **无序性**：存储是哈希化的，遍历顺序不固定。

- **应用场景**：存储配置、缓存搜索结果。

```zsh
typeset -A user_info
user_info=(name "Gemini" role "AI" version "3.0")
echo $user_info[name]

```

---

### 4. 集合 (Sets)

虽然 Zsh 没有独立的 `set` 类型，但它通过 **属性修饰 (Attributes)** 让数组表现得像集合。

- **唯一性标志 (`-U`)**：

```zsh
typeset -U my_list
my_list=(a a b c b)
echo $my_list      # 输出 a b c (重复项被自动过滤)

```

这也是为什么 `$path` 通常被声明为 `-U`，防止路径重复叠加导致搜索变慢。

---

### 5. 核心数据结构的“幕后英雄”：修饰符与标志

Zsh 的数据结构之所以强大，是因为它有一套完整的**元编程符号**：

| 符号      | 名称      | 作用                                             |
| --------- | --------- | ------------------------------------------------ |
| **`(k)`** | Keys      | 获取关联数组的所有键                             |
| **`(v)`** | Values    | 获取关联数组的所有值（默认）                     |
| **`(f)`** | Flat      | 按行分割字符串为数组（常用于处理文件读取）       |
| **`(z)`** | Zsh-split | 按 Shell 语法规则分割字符串（智能识别引号/空格） |

---

### 6. 技术背景：内存与生存周期

- **Copy-on-Write**：Zsh 在处理大型数组展开时，内部尽量减少内存拷贝，以提高性能。
- **作用域控制**：通过 `local` 和 `typeset` 实现函数级作用域。Zsh 甚至支持 **动态作用域**，这意味着子函数可以访问父函数中定义的 `local` 变量。

---

### 总结建议

如果你在编写复杂的脚本（如你之前的 `show_paths` 或路径搜索工具）：

1. **路径/列表类**：永远用 `typeset -aU`（数组 + 唯一化）。
2. **配置/映射类**：永远用 `typeset -A`（关联数组）。
3. **字符串解析**：优先使用 `(${(z)var})` 而不是手动切分。

这是一个 Zsh 数据结构的快速参考清单，涵盖了从基础变量到高级模块提供的特殊结构。

---

### 1. 核心基础类型

这是你每天都会用到的三种基本结构：

| 类型                 | 声明方式       | 特点                                        | 适用场景                       |
| -------------------- | -------------- | ------------------------------------------- | ------------------------------ |
| **标量 (Scalar)**    | `var="val"`    | 纯字符串或数字。                            | 存储路径、开关、简单配置。     |
| **普通数组 (Array)** | `arr=(a b)`    | **下标从 1 开始**；支持切片和各种展开标志。 | 存储列表、文件集合、命令参数。 |
| **关联数组 (Hash)**  | `typeset -A h` | 键值对映射（Key-Value）；无序存储。         | 字典、缓存、复杂配置映射。     |

---

### 2. 特殊行为结构

通过 `typeset` 修饰符赋予数组特殊性质：

- **唯一数组 (Set/Unique Array)**:
- 声明：`typeset -U arr`
- 特性：自动过滤重复项（常用于 `$path`）。

- **绑定变量 (Tied Variable)**:
- 声明：`typeset -T SCALAR array :`
- 特性：标量字符串与数组实时同步（如 `$PATH` 与 `$path`）。

---

### 3. 系统级内置结构

Zsh 内部维护的特殊数据对象：

- **目录栈 (Directory Stack)**:
- 变量：`$dirstack`
- 结构：LIFO（后进先出）栈。通过 `pushd`/`popd` 操作。

- **历史记录 (History)**:
- 变量：`$history` (需加载 `zsh/parameter` 模块)
- 结构：关联数组。键为行号，值为命令内容。

- **作业表 (Job Table)**:
- 变量：`$jobtexts`, `$jobstates`
- 结构：关联数组。记录后台进程的状态和命令源码。

---

### 4. 交互式缓冲区 (ZLE Buffer)

在 Zsh 行编辑器 (ZLE) 中操作的实时数据结构：

- **`$BUFFER`**: 当前输入的完整字符串。
- **`$LBUFFER`**: 光标左侧的字符串。
- **`$RBUFFER`**: 光标右侧的字符串。
- **`$words`**: 当前命令行按单词分割后的数组。

---

### 5. 高级模块结构 (Modules)

通过 `zmodload` 加载的特殊数据能力：

- **`zsh/mapfile`**:
- 将整个文件映射为一个关联数组。键是文件名，值是文件内容。

- **`zsh/db/gdbm`**:
- 将磁盘上的 GDBM 数据库映射为 Zsh 关联数组，实现数据持久化。

- **`zsh/net/tcp`**:
- 将网络会话抽象为文件描述符流。

---

### 6. 数据处理“伪结构”

通过 **展开标志 (Parameter Flags)** 临时改变数据的组织形式：

- **`(z)`**: 将字符串按 Shell 词法解析为数组。
- **`(f)`**: 将文本按行分割为数组。
- **`(s:sep:)`**: 按指定分隔符 `sep` 切割。
- **`(k/v)`**: 提取哈希表的键或值。

---

### 总结：如何选择？

- 需要去重？`typeset -U`。
- 需要快速查找？`typeset -A`。
- 需要处理路径？`typeset -T` 绑定。
- 需要处理多行文本？用 `(f)` 标志将标量转为数组。

**你想让我演示一下如何用 `zsh/mapfile` 像操作变量一样直接修改文件内容，而不用通过 `sed` 或重定向吗？**
