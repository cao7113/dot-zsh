# hash -d Static Named Directories

```
hash -d dev=~/work/project 高级用法和背景
```

`hash -d` 是 Zsh 中一个非常强大但常被低估的特性，正式名称叫 **"Static Named Directories"（静态命名目录）**。

它不仅仅是给目录起个别名，而是直接干预了 Zsh 对路径的**解析**和**缩写显示**。

---

### 1. 核心背景：为什么要用它？

在 Shell 中，我们习惯用 `~` 代表家目录。Zsh 的 `hash -d` 允许你**定义自己的“波浪号”**。

- **痛点**：常用的项目路径太深，比如 `/Users/rj/dev/ops/projects/kubernetes/configs`。
- **传统方案**：用 `alias` 或变量 `$configs`。但变量在补全时不够直观，且不会影响提示符（Prompt）的显示。
- **Zsh 方案**：使用 `hash -d`。定义后，这个路径在 Zsh 眼中就等同于 `~name`。

---

### 2. 高级用法

#### A. 路径自动缩写（Prompt Optimization）

当你定义了 `hash -d dot=$HOME/.zsh_dots` 后，如果你进入该目录：

- 执行 `pwd` 会显示完整路径。
- 但你的 **Prompt（提示符）** 如果使用了 `%~`，它会自动从 `/Users/rj/...` 变成 `~dot`。

#### B. 动态路径补全

定义后，你可以直接在任何命令后面使用：

```zsh
cd ~dev          # 直接跳转
ls ~dev/src      # 路径补全依然有效
cp file ~dev/    # 极快地操作跨目录文件

```

#### C. 在脚本中解耦路径

在你的 `source_dir_files` 或其他脚本中，可以使用这些哈希路径：

```zsh
hash -d mytools=/Users/rj/dev/ops/tools
source ~mytools/rc.zsh

```

这样做的好处是：如果以后目录迁移了，你只需要在配置文件中改一行 `hash -d`，所有引用 `~mytools` 的脚本都会自动生效。

---

### 3. 与普通变量/别名的区别

| 特性           | 变量 (`$dev`) | 别名 (`alias`) | `hash -d` (`~dev`)         |
| -------------- | ------------- | -------------- | -------------------------- |
| **补全支持**   | 需按 `$` 触发 | 仅限命令开头   | **原生支持，Tab 极其顺滑** |
| **提示符缩写** | ❌ 不缩写     | ❌ 不缩写      | ✅ **自动显示为 `~dev**`   |
| **路径拼接**   | `$dev/path`   | ❌ 不支持      | `~dev/path`                |
| **双向映射**   | 仅单向        | 仅单向         | **双向（路径 <-> 名字）**  |

---

### 4. 自动化的高级技巧：批量 Hash

如果你有很多项目都在同一个目录下，可以利用 Zsh 的 `for` 循环批量挂载：

```zsh
# 自动将 ~/work 下的所有子目录映射为 ~name
for dir in ~/work/*(/); do
  hash -d "${dir:t}"="$dir"
done

```

执行后，如果你有个文件夹叫 `~/work/titan`，你直接 `cd ~titan` 就能进去。`${dir:t}` 的意思是取目录的最后一个部分（Tail）。

---

### 5. 注意事项

1. **优先级**：如果你定义的名称和系统用户名冲突（比如有个用户叫 `rj`），Zsh 优先解析用户名。
2. **持久化**：`hash -d` 的定义只在当前 Session 有效，必须写在 `.zshrc` 中才能永久生效。
3. **大写规范**：虽然没有强制规定，但很多人喜欢用大写（如 `hash -d PROJ=...`）来避免与普通文件混淆，尽管 Zsh 对大小写敏感。

**既然你在构建 `tools` 加载器，你想把工具箱的各个子目录（如 git, docker）自动映射为 `~git` 和 `~docker` 这种哈希路径吗？这样你在终端里操作这些目录会快到飞起。**
