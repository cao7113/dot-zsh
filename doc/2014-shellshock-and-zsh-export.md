# 2014年Shellshock (CVE-2014-6271)

**Zsh 不支持导出函数**，既有**设计哲学**上的考量，也有对**安全风险**的规避。

我们可以深入剖析一下，为什么 Bash 的这个“便利功能”最终演变成了安全史上著名的灾难，以及 Zsh 是如何通过不同的路径解决问题的。

---

### 1. Shellshock 漏洞的本质：边界模糊

在 Bash 中，导出函数的实现方式极度“投机”：它将函数定义伪装成一个普通的**环境变量**。

- **Bash 的逻辑**：如果一个环境变量的值以 `() {` 开头，那么在启动新的 Shell 进程时，Bash 会自动将其 `eval`（执行）并转化为函数。
- **漏洞所在**：2014 年发现的 **Shellshock (CVE-2014-6271)** 证明，Bash 在解析这些变量时，不会在函数定义结束处停止，而是会继续执行后面的非法指令。

> **攻击示例：**
> 攻击者只需设置一个恶意环境变量：
> `export HTTP_USER_AGENT='() { :; }; echo "你被黑了"; /bin/rm -rf /'`
> 当 Web 服务器（如 Apache 通过 CGI）调用 Bash 时，哪怕只是为了查个时间，这段 `echo` 和 `rm` 命令也会被**自动执行**。

---

### 2. Zsh 的设计哲学：显式胜于隐式

Zsh 的开发者（以及早期的本地 Shell 开发者）认为，**环境 (Environment)** 应该只存放**数据 (Data)**，而不应该存放**逻辑 (Code)**。

- **数据 vs 逻辑**：环境变量应该简单如 `PATH=/usr/bin`。如果把复杂的脚本逻辑塞进环境变量，就模糊了数据和代码的边界。
- **性能考量**：Bash 在每次启动子进程时，都要扫描成百上千个环境变量，检查是否有 `() {` 开头的字符串并解析。这在高性能要求的场景下是一种浪费。Zsh 倾向于按需加载（Autoloading）。

---

### 3. Zsh 是如何实现“函数共享”的？

虽然 Zsh 不通过 `typeset -x` 导出函数，但它提供了一个更优雅、更工业化的方案：**`FPATH` 与 `autoload**`。

#### Zsh 的做法：

1. **建立函数库**：将你的函数写在独立的文件里，文件名就是函数名。
2. **设置路径**：将该文件夹路径加入 `fpath` 变量。
3. **自动加载**：使用 `autoload -Uz func_name`。

这种方式的优势在于：

- **按需读取**：只有在你真正调用函数时，Zsh 才会去磁盘读取代码，而不是在启动每个子 Shell 时都加载一遍。
- **无污染**：环境变量保持干净，完全免疫类似 Shellshock 的攻击。

---

### 4. 总结：安全的代价与收益

Bash 选择牺牲安全性来换取“父子进程无缝继承”的便利；而 Zsh 选择强制用户显式管理函数库，从而换取了更高的安全边界和更清晰的架构。

| 维度         | Bash (Export Function)            | Zsh (fpath/autoload)       |
| ------------ | --------------------------------- | -------------------------- |
| **传递媒介** | 环境变量 (Strings)                | 文件系统路径 (fpath)       |
| **触发方式** | 自动解析 (隐式)                   | 显式声明 (显式)            |
| **安全性**   | 容易受到注入攻击 (已修复但仍复杂) | 天然免疫此类注入           |
| **维护性**   | 适合临时的小脚本                  | 适合构建大型、复杂的工具链 |

---

### 💡 思考

如果你正在从 Bash 迁移到 Zsh，你会发现 `fpath` 虽然起步稍显繁琐，但它能让你的 `.zshrc` 保持极度精简，因为你不再需要把成百上千行的函数定义直接塞进配置文件里。

**你想尝试配置一个属于你自己的 Zsh `fpath` 函数库吗？我可以给你演示具体的步骤。**
